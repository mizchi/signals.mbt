// Generated using `moon info`, DON'T EDIT IT
package "mizchi/signals/ui"

// Values
pub fn[E, A] async_(render~ : async () -> Node[E, A], fallback~ : () -> Node[E, A], on_error? : ((Error) -> Node[E, A])?) -> Node[E, A]

pub fn[E, A] attr_dynamic(() -> A) -> Attr[E, A]

pub fn[E] attr_dynamic_style(() -> String) -> Attr[E, String]

pub fn[E, A] attr_handler(EventHandler[E]) -> Attr[E, A]

pub fn[E, A] attr_static(A) -> Attr[E, A]

pub fn[E] attr_style(String) -> Attr[E, String]

pub fn[E, A] component(() -> Node[E, A]) -> Node[E, A]

pub fn[E, A] error_boundary(children~ : () -> Node[E, A] raise, fallback~ : (Error, () -> Unit) -> Node[E, A] raise) -> Node[E, A]

pub fn[E, A] for_each(() -> Array[Node[E, A]]) -> Node[E, A]

pub fn[E, A] fragment(Array[Node[E, A]]) -> Node[E, A]

pub fn[E, A] h(String, Array[(String, Attr[E, A])], Array[Node[E, A]]) -> Node[E, A]

pub fn[E] handler((E) -> Unit) -> EventHandler[E]

pub fn[E, A] has_dynamic_content(Array[(String, Attr[E, A])]) -> Bool

pub fn[E, A] match_case(when~ : () -> Bool, render~ : () -> Node[E, A]) -> MatchCase[E, A]

pub fn[E, A] raw_html(String) -> Node[E, A]

pub fn[E, A] show(() -> Bool, () -> Node[E, A]) -> Node[E, A]

pub fn[E, A] switch_(cases~ : Array[MatchCase[E, A]], fallback? : (() -> Node[E, A])?) -> Node[E, A]

pub fn[E, A] text(String) -> Node[E, A]

pub fn[E, A] text_dyn(() -> String) -> Node[E, A]

// Errors

// Types and methods
pub(all) enum AsyncState[T] {
  Pending
  Success(T)
  Failure(String)
}
pub fn[T] AsyncState::error(Self[T]) -> String?
pub fn[T] AsyncState::is_failure(Self[T]) -> Bool
pub fn[T] AsyncState::is_pending(Self[T]) -> Bool
pub fn[T] AsyncState::is_success(Self[T]) -> Bool
pub fn[T] AsyncState::value(Self[T]) -> T?

pub(all) enum Attr[E, A] {
  VStatic(A)
  VDynamic(() -> A)
  VHandler(EventHandler[E])
}

pub struct EventHandler[E] {
  callback : (E) -> Unit
}
pub fn[E] EventHandler::get_callback(Self[E]) -> (E) -> Unit

pub struct MatchCase[E, A] {
  when : () -> Bool
  render : () -> Node[E, A]
}

pub(all) enum Node[E, A] {
  Element(VElement[E, A])
  Text(String)
  DynamicText(() -> String)
  Fragment(Array[Node[E, A]])
  Show(condition~ : () -> Bool, child~ : () -> Node[E, A])
  For(render~ : () -> Array[Node[E, A]])
  Component(render~ : () -> Node[E, A])
  Async(VAsync[E, A])
  ErrorBoundary(VErrorBoundary[E, A])
  Switch(VSwitch[E, A])
  RawHtml(String)
}

pub struct VAsync[E, A] {
  render : async () -> Node[E, A]
  fallback : () -> Node[E, A]
  on_error : ((Error) -> Node[E, A])?
}

pub struct VElement[E, A] {
  tag : String
  attrs : Array[(String, Attr[E, A])]
  children : Array[Node[E, A]]
}

pub struct VErrorBoundary[E, A] {
  children : () -> Node[E, A] raise
  fallback : (Error, () -> Unit) -> Node[E, A] raise
}

pub struct VSwitch[E, A] {
  cases : Array[MatchCase[E, A]]
  fallback : (() -> Node[E, A])?
}

// Type aliases

// Traits

